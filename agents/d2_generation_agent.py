"""
D2 Generation Agent - Converts analyzed code data into D2 syntax.
"""

from typing import List, Dict, Any, Set
from data_models import (
    CodeAnalysisResult, DiagramDesign, D2Generation, CodeComponent,
    ComponentType, RelationshipType, LayoutStrategy
)


class D2GenerationAgent:
    """Generates D2 syntax from analyzed code and diagram design."""

    def __init__(self):
        self.name = "D2GenerationAgent"
        self.d2_code_lines: List[str] = []
        self.components_map: Dict[str, CodeComponent] = {}

    def generate_d2(self, analysis_result: CodeAnalysisResult,
                   diagram_design: DiagramDesign) -> D2Generation:
        """Generate D2 code from analysis and design specifications."""
        # Reset state
        self.d2_code_lines = []
        self.components_map = {c.name: c for c in analysis_result.components}

        # Add header and styling
        self._add_header(diagram_design)

        # Generate components
        self._generate_components(analysis_result, diagram_design)

        # Generate relationships
        self._generate_relationships(diagram_design)

        # Generate groups/containers
        self._generate_groups(diagram_design)

        # Add layout settings
        self._add_layout_settings(diagram_design)

        d2_code = "\n".join(self.d2_code_lines)

        return D2Generation(
            d2_code=d2_code,
            diagram_type=diagram_design.diagram_type,
            layout_strategy=diagram_design.layout_strategy,
            components_used=diagram_design.components_to_include,
            generation_metadata={
                "lines_generated": len(self.d2_code_lines),
                "components_rendered": len(diagram_design.components_to_include),
                "groups_created": len(diagram_design.grouping_strategy)
            }
        )

    def _add_header(self, diagram_design: DiagramDesign):
        """Add D2 header and global styling."""
        self.d2_code_lines.extend([
            "# D2 Diagram generated by Agentic D2 Diagram Generator",
            f"# Diagram Type: {diagram_design.diagram_type.value}",
            f"# Layout Strategy: {diagram_design.layout_strategy.value}",
            "",
        ])

        # Add global styling with better readability settings
        settings = diagram_design.visual_settings
        self.d2_code_lines.extend([
            "# Global Styling",
            "direction: " + self._get_direction_string(diagram_design.layout_strategy),
            "style.font-size: " + str(settings.get("font_size", 16)),  # Larger font
            "gap: 80",  # Better spacing
            ""
        ])

    def _generate_components(self, analysis_result: CodeAnalysisResult,
                           diagram_design: DiagramDesign):
        """Generate D2 components for included items."""
        components_map = {c.name: c for c in analysis_result.components}
        settings = diagram_design.visual_settings

        for comp_name in diagram_design.components_to_include:
            if comp_name not in components_map:
                continue

            component = components_map[comp_name]
            self._generate_single_component(component, settings)

    def _generate_single_component(self, component: CodeComponent, settings: Dict[str, Any]):
        """Generate D2 code for a single component."""
        if component.type == ComponentType.CLASS:
            self._generate_class_component(component, settings)
        elif component.type == ComponentType.FUNCTION:
            self._generate_function_component(component, settings)
        elif component.type == ComponentType.VARIABLE:
            self._generate_variable_component(component, settings)

    def _generate_class_component(self, component: CodeComponent, settings: Dict[str, Any]):
        """Generate D2 code for a class component."""
        # Create a more informative label
        label_lines = [component.name]

        # Add methods if enabled and available
        if settings.get("show_methods", True) and component.methods:
            # Show up to 5 most important methods
            important_methods = [m for m in component.methods if not m.startswith('_')][:5]
            if important_methods:
                label_lines.append("---")
                for method in important_methods:
                    label_lines.append(f"+ {method}()")

        # Create the D2 object with enhanced styling
        label_text = self._escape_label("\\n".join(label_lines))
        self.d2_code_lines.extend([
            f'"{component.name}" {{',
            f'  label: "{label_text}"',
            f'  shape: rectangle'
        ])

        # Add color based on type with better color scheme
        if component.metadata.get("is_abstract"):
            self.d2_code_lines.extend([
                f'  style.fill: "#FFE5CC"',
                f'  style.stroke: "#FF9800"',
                f'  style.stroke-width: 2'
            ])
        else:
            self.d2_code_lines.extend([
                f'  style.fill: "#E3F2FD"',
                f'  style.stroke: "#1976D2"',
                f'  style.stroke-width: 1'
            ])

        self.d2_code_lines.extend(["}", ""])

    def _generate_function_component(self, component: CodeComponent, settings: Dict[str, Any]):
        """Generate D2 code for a function component."""
        label = component.name

        # Add parameters if available
        args = component.metadata.get("arguments", [])
        if args and settings.get("show_metadata", False):
            label += f"({', '.join(args[:2])}"  # Show max 2 args
            if len(args) > 2:
                label += "..."
            label += ")"

        self.d2_code_lines.extend([
            f'"{component.name}" {{',
            f'  label: "{label}"',
            f'  shape: rectangle',
            f'  style.fill: "#F1F8E9"',
            f'  style.stroke: "#689F38"',
            "}",
            ""
        ])

    def _generate_variable_component(self, component: CodeComponent, settings: Dict[str, Any]):
        """Generate D2 code for a variable component."""
        self.d2_code_lines.extend([
            f'"{component.name}" {{',
            f'  label: "{component.name}"',
            f'  shape: ellipse',
            f'  style.fill: "#FFF3E0"',
            f'  style.stroke: "#F57C00"',
            "}",
            ""
        ])

    def _escape_label(self, label: str) -> str:
        """Escape special characters in D2 labels."""
        # D2 supports actual newlines in labels, so we don't need to escape them
        return label

    def _generate_variable_component(self, component: CodeComponent, settings: Dict[str, Any]):
        """Generate D2 code for a variable component."""
        self.d2_code_lines.extend([
            f'"{component.name}" {{',
            f'  label: "{component.name}"',
            f'  style.fill: "#FFF3E0"',
            "}",
            ""
        ])

    def _generate_relationships(self, diagram_design: DiagramDesign):
        """Generate D2 relationships between components."""
        self.d2_code_lines.append("# Relationships")
        self.d2_code_lines.append("")

        components_set = set(diagram_design.components_to_include)
        processed_relationships = set()

        for comp_name in diagram_design.components_to_include:
            if comp_name not in self.components_map:
                continue

            component = self.components_map[comp_name]

            for relationship in component.relationships:
                # Only include relationships between selected components
                if (relationship.target not in components_set or
                    relationship.source not in components_set):
                    continue

                # Avoid duplicate relationships
                rel_key = tuple(sorted([relationship.source, relationship.target]))
                if rel_key in processed_relationships:
                    continue
                processed_relationships.add(rel_key)

                self._generate_single_relationship(relationship)

    def _generate_single_relationship(self, relationship):
        """Generate D2 code for a single relationship."""
        edge_style = self._get_edge_style(relationship.type)

        self.d2_code_lines.extend([
            f'"{relationship.source}" -> "{relationship.target}" {{',
        ])

        # Add style on separate line
        if edge_style:
            self.d2_code_lines.append(f'  {edge_style}')

        self.d2_code_lines.extend(["}", ""])

    def _generate_groups(self, diagram_design: DiagramDesign):
        """Generate D2 groups/containers."""
        if not diagram_design.grouping_strategy:
            return

        self.d2_code_lines.append("# Groups")
        self.d2_code_lines.append("")

        for group_name, components in diagram_design.grouping_strategy.items():
            # Filter components that are actually included
            valid_components = [c for c in components if c in diagram_design.components_to_include]
            if len(valid_components) < 2:
                continue

            self.d2_code_lines.extend([
                f'"{group_name}" {{',
                "  label: " + self._format_group_label(group_name),
            ])

            for comp in valid_components:
                self.d2_code_lines.append(f'  "{comp}"')

            self.d2_code_lines.extend(["}", ""])

    def _add_layout_settings(self, diagram_design: DiagramDesign):
        """Add layout-specific settings."""
        settings = diagram_design.visual_settings
        layout_strategy = diagram_design.layout_strategy

        self.d2_code_lines.append("# Layout Settings")

        if layout_strategy == LayoutStrategy.LAYERED:
            self.d2_code_lines.extend([
                "layer-distance: 150",
                "edge-gap: 50"
            ])
        elif layout_strategy == LayoutStrategy.HIERARCHICAL:
            self.d2_code_lines.extend([
                "rank-distance: 100",
                "node-distance: 80"
            ])

        if settings.get("spacing"):
            self.d2_code_lines.append(f"gap: {settings['spacing']}")

        self.d2_code_lines.append("")

    def _get_direction_string(self, layout_strategy) -> str:
        """Get D2 direction string for layout strategy."""
        direction_map = {
            LayoutStrategy.HIERARCHICAL: "down",  # Top to Bottom
            LayoutStrategy.LAYERED: "right",       # Left to Right
            LayoutStrategy.CIRCULAR: "down",
            LayoutStrategy.GRID: "right"
        }
        return direction_map.get(layout_strategy, "down")

    def _get_edge_style(self, relationship_type: RelationshipType) -> str:
        """Get edge style for relationship type."""
        style_map = {
            RelationshipType.INHERITANCE: 'style.stroke: "#2196F3"',
            RelationshipType.COMPOSITION: 'style.stroke: "#4CAF50"',
            RelationshipType.DEPENDENCY: 'style.stroke: "#757575"',
            RelationshipType.ASSOCIATION: 'style.stroke: "#9E9E9E"',
            RelationshipType.METHOD_CALL: 'style.stroke: "#FF9800"'
        }
        return style_map.get(relationship_type, 'style.stroke: "#757575"')

    def _get_arrow_style(self, relationship_type: RelationshipType) -> str:
        """Get arrow style for relationship type."""
        arrow_map = {
            RelationshipType.INHERITANCE: "arrowhead: triangle",
            RelationshipType.COMPOSITION: "arrowhead: diamond",
            RelationshipType.DEPENDENCY: "arrowhead: none",
            RelationshipType.ASSOCIATION: "arrowhead: V",
            RelationshipType.METHOD_CALL: "arrowhead: V"
        }
        return arrow_map.get(relationship_type, "arrowhead: V")

    def _format_group_label(self, group_name: str) -> str:
        """Format group label for display."""
        # Clean up group name for display
        if group_name.startswith("module_"):
            return f'"Module: {group_name[7:]}"'
        elif group_name.startswith("hierarchy_"):
            return f'"Hierarchy: {group_name[10:]}"'
        else:
            return f'"{group_name.title()}"'